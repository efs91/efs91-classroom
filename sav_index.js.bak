import express from "express";
import Docker from "dockerode";
import getPort from "get-port";
import path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const docker = new Docker();
const app = express();
app.use(express.json());
app.use(express.static(path.join(__dirname, "public")));

// --- utilitaire pour avoir un nom docker sÃ»r (sans accents) ---
function slugifyName(name) {
  return name
    .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // enlÃ¨ve les accents
    .toLowerCase()
    .replace(/[^a-z0-9_-]/g, "_");
}

// --- cherche un port libre entre 5801 et 5900 ---
async function findFreePort(start = 5801, end = 5900) {
  for (let p = start; p <= end; p++) {
    const free = await getPort({ port: p });
    if (free === p) return p;
  }
  throw new Error("Aucun port libre trouvÃ©");
}

// ---- API ----

// CrÃ©er une session
app.post("/session", async (req, res) => {
  const rawName = req.body.name;
  if (!rawName) return res.status(400).json({ error: "name is required" });

  const name = slugifyName(rawName);

  try {
    const port = await findFreePort();
    const containerName = `scratch_${name}_${port}`;

    // CrÃ©er des volumes nommÃ©s pour Ã©viter les volumes anonymes
    const volumeName = `scratch_${name}_${port}`;
    
    const container = await docker.createContainer({
      Image: "jlesage/firefox",
      name: containerName,
      Env: [
        "FF_OPEN_URL=https://scratch.mit.edu/projects/editor",
        "DISPLAY_WIDTH=1280",
        "DISPLAY_HEIGHT=800",
        "WEB_AUDIO=1"
      ],
      HostConfig: {
        PortBindings: { "5800/tcp": [{ HostPort: port.toString() }] },
        Binds: [
          `${volumeName}_config:/config`,
          `${volumeName}_home:/config/xdg/config/mozilla`
        ]
      }
    });

    await container.start();
    console.log(`âœ… Session crÃ©Ã©e pour ${rawName} (${name}) sur http://localhost:${port}`);

    // attendre un peu que le service web soit prÃªt avant de donner l'URL
    setTimeout(() => {
      res.json({
        name: rawName,
        url: `http://${req.hostname || "localhost"}:${port}`,
        containerId: container.id
      });
    }, 2000);

  } catch (err) {
    console.error("Erreur crÃ©ation session:", err);
    res.status(500).json({ error: err.message });
  }
});

// Lister les sessions (uniquement celles qui tournent)
app.get("/sessions", async (_req, res) => {
  try {
    const containers = await docker.listContainers(); // par dÃ©faut : seulement running
    const sessions = containers
      .filter(c => c.Image.includes("jlesage/firefox"))
      .map(c => ({
        id: c.Id,
        name: c.Names[0].replace(/^\//, ""),
        port: c.Ports.find(p => p.PrivatePort === 5800)?.PublicPort
      }));
    res.json(sessions);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Stopper une session
app.delete("/session/:id", async (req, res) => {
  try {
    const container = docker.getContainer(req.params.id);
    const containerInfo = await container.inspect();
    const containerName = containerInfo.Name.replace('/', '');
    
    await container.stop();
    await container.remove({ v: true }); // v: true supprime aussi les volumes associÃ©s
    
    // Extraire le nom de base pour les volumes (ex: scratch_martin_5801 -> martin_5801)
    const volumeBaseName = containerName.replace('scratch_', '');
    console.log(`ðŸ” Conteneur: ${containerName} -> Base volumes: ${volumeBaseName}`);
    
    // Supprimer explicitement les volumes nommÃ©s
    const configVolumeName = `scratch_${volumeBaseName}_config`;
    const homeVolumeName = `scratch_${volumeBaseName}_home`;
    
    console.log(`ðŸŽ¯ Tentative suppression volumes: ${configVolumeName} et ${homeVolumeName}`);
    
    try {
      const configVolume = docker.getVolume(configVolumeName);
      await configVolume.remove();
      console.log(`âœ… Volume ${configVolumeName} supprimÃ© avec succÃ¨s`);
    } catch (e) { 
      console.log(`âŒ Erreur suppression ${configVolumeName}:`, e.message);
    }
    
    try {
      const homeVolume = docker.getVolume(homeVolumeName);
      await homeVolume.remove();
      console.log(`âœ… Volume ${homeVolumeName} supprimÃ© avec succÃ¨s`);
    } catch (e) { 
      console.log(`âŒ Erreur suppression ${homeVolumeName}:`, e.message);
    }
    
    console.log(`ðŸ›‘ Session ${req.params.id} (${containerName}) arrÃªtÃ©e et volumes supprimÃ©s`);
    res.json({ ok: true });
  } catch (err) {
    console.error("Erreur suppression session:", err);
    res.status(500).json({ error: err.message });
  }
});

// ---- Lancement serveur ----
const PORT = 3000;
app.listen(PORT, () => {
  console.log(`ðŸš€ Orchestrateur dispo sur http://localhost:${PORT}`);
});
